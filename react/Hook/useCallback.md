# useCallback

- 이전에 만들었던 함수를 새로 만들지 않고 재사용
- useCallback은 이벤트 핸들러 함수를 필요할 때만 생성할 수 있다.

## useCallback 함수가 필요한 이유?

- 이벤트 핸들러 함수들은 컴포넌트가 리렌더링될때마다 함수가 생성된다.
- 이런 방식이 대체로 별로 문제가 없지만, 컴포넌트의 렌더링이 자주 발생하거나 렌더링할 컴포넌트가 많아지면 최적화해주는 것이 좋다.
- 컴포넌트들의 props가 바뀌지 않았을 때에는 가상돔에서 리렌더링하지 않도록 만들 수 있는데, 이 때 함수들이 매번 생성되는 방식이라면 이전에 만든 결과물을 추적할 수 없기 때문에 한번 만든 함수는 재사용할 수 있도록 만들어야한다.

## useCallback을 사용하는 경우와 사용하지 않는 경우

**사용하지 않는 경우**

- 함수 컴포넌트 안에서만 사용되는 함수(ex. 이벤트 리스너)는 useCallback을 사용하지 않아도 된다.
- 메모이제이션이 성능 최적화에 항상 정답은 아니다. 작은 변화 때문에 메모이제이션을 하게 되면 더 많은 메모리를 사용하게될 수도 있다.
- useCallback 훅을 사용하지 않은 코드는 실행 된 이후 가비지 컬렉터에 의해 제거 되지만, useCallback 훅을 사용한 코드는 메모이제이션 되어 가비지 컬렉터에 의해 제거되지 않고 의존 속성에 묶여 오래된 값들의 복사본을 기억해야 한다. <span style="color: teal">⇒ 더 많은 메모리를 할당하게될 수 있다.</span>

**사용하는 경우**

- 중첩된 컴포넌트(하위 컴포넌트) 내에서 함수를 props로 전달하는 경우 useCallback 훅을 사용하는 것이 권장된다.
- 하위 컴포넌트 내에 전달된 함수는 하위 컴포넌트에서 이벤트가 발생할 때 실행되어야 하므로, 함수를 메모리에서 지우고 할당하는 것보다, 기억된 함수를 사용하는 것이 더 좋다.

## useCallback의 사용

```js
const memoizedCallback = useCallback(
  // 첫번째 인수 : 생성하고 싶은 함수
  () => {
    doSomething(a, b)
  },
  // 두번째 인수 : deps
  [a, b]
)
```

<span style="background-color: linen">**인수**</span>

1. 생성하고 싶은 함수
2. 배열(deps)
   - 배열 안의 값들이 바뀔때 함수를 새로 생성한다.
   - 빈배열인 경우 컴포넌트가 렌더링될 때 한 번만 함수가 생성된다.
   - 함수를 props로 받아와서 콜백 내부에서 사용해야 한다면 이것도 deps에 넣어야 한다.

[🔗 예시 링크](https://github.com/Bernese-Corgi/react-practice/commit/08e45f51c8bde9f066985e9424c522531c1490c0)
